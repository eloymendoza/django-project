<!DOCTYPE html>
<html>
  <head>
    <title>Detección de Rostros en Tiempo Real</title>
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <style>
      body {
        margin: 0;
        position: relative;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      canvas,
      video {
        position: absolute;
        top: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 100%; /* Establece el ancho al 50% de la ventana */
        height: auto; /* Mantiene la relación de aspecto */
      }
    </style>
  </head>
  <body>
    <video id="video" autoplay muted></video>
    <canvas id="canvas"></canvas>
    <script>
        let canvas, displaySize;
        const video = document.getElementById('video');
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const inputSize = isMobile ? 160 : 512; // Menor tamaño de entrada para móviles
        const scoreThreshold = 0.5;
        const options = new faceapi.TinyFaceDetectorOptions({ inputSize, scoreThreshold });
        let expressionHistory = [];
        const requiredConsistency = 20; // Número de cuadros consecutivos requeridos

        let framesSinceLastDetection = 0;
        const detectionFrequency = isMobile ? 5 : 1;
        
        Promise.all([
            faceapi.nets.tinyFaceDetector.loadFromUri("/static/models"),
            faceapi.nets.faceLandmark68Net.loadFromUri("/static/models"), // Modelo completo para dispositivos no móviles
            faceapi.nets.faceLandmark68TinyNet.loadFromUri("/static/models"), // Modelo más ligero para móviles
            faceapi.nets.faceExpressionNet.loadFromUri("/static/models"),
            // Carga aquí otros modelos si los necesitas
        ]).then(startVideo);
        
        function startVideo() {
            navigator.getUserMedia(
                { video: {} },
                (stream) => {
                    video.srcObject = stream;
                    video.onloadedmetadata = () => {
                        video.play();
                        if (isMobile) {
                            video.width = video.videoWidth / 2;
                            video.height = video.videoHeight / 2;
                        }
        
                        canvas = faceapi.createCanvasFromMedia(video);
                        document.body.append(canvas);
                        displaySize = { width: video.videoWidth, height: video.videoHeight };
                        faceapi.matchDimensions(canvas, displaySize);
        
                        detectFaces();
                    };
                },
                (err) => console.error(err)
            );
        }
        
        async function detectFaces() {
            if (!isMobile || framesSinceLastDetection++ >= detectionFrequency) {
                let detections = await faceapi
                    .detectAllFaces(video, options)
                    .withFaceLandmarks(isMobile ? false : true)
                    .withFaceExpressions(); 
                    
        
                const resizedDetections = faceapi.resizeResults(detections, displaySize);
                canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
                faceapi.draw.drawDetections(canvas, resizedDetections);
                faceapi.draw.drawFaceLandmarks(canvas, resizedDetections);
                faceapi.draw.drawFaceExpressions(canvas, resizedDetections);
        
                // Agrega aquí la lógica para evaluar las expresiones
                const expressions = resizedDetections.map(d => d.expressions);
                expressionHistory.push(expressions);
        
                if (expressionHistory.length > requiredConsistency) {
                    expressionHistory.shift();
                }
        
                if (isExpressionConsistent(expressionHistory, 'happy')) {
                    alert("Validación exitosa para happy");
                    // Realiza alguna acción cuando la expresión sea consistente
                }
                 if (isExpressionConsistent(expressionHistory, 'neutral')) {
                    alert("Validación exitosa para Neutral");
                    // Realiza alguna acción cuando la expresión sea consistente
                }
        
                framesSinceLastDetection = 0;
            }
        
            requestAnimationFrame(detectFaces);
        }
        
        function isExpressionConsistent(history, expression) {
            // Asegúrate de que cada historial de expresiones contenga la expresión deseada como la más prominente
            return history.every(h => {
                const maxExpression = h.length > 0 ? h[0].asSortedArray()[0].expression : '';
                return maxExpression === expression;
            });
        }

      function sendFrame() {
 
        if (isFrameSent) {
            return; // Evitar que la función se ejecute si ya se ha enviado el frame
        }

        isFrameSent = true; // Actualizar la variable de control

        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0);
        const data = canvas.toDataURL('image/jpeg');
        fetch('../api/ReconFacial/', {
            method: 'POST',
            body: JSON.stringify({ imagen_base64: data }),
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': getCookie('csrftoken')
            }
        })
            .then(response => response.json())
            .then(data => {
                console.log(data);
                if (data.match) {
                    // Si hay coincidencia, ocultamos el video y el canvas
                    video.style.display = 'none';
                    canvas.style.display = 'none';
                    // Detener la detección y el stream de la cámara
                    stopCameraStream();
                } else {
                    alert("usuario no encontrado");
                    // Opcional: resetear isFrameSent si quieres permitir reintentos
                    isFrameSent = false;
                }
            })
            .catch(error => {
                console.error('Error al enviar la imagen:', error);
                // Opcional: resetear isFrameSent si quieres permitir reintentos
                isFrameSent = false;
            });

    }

      function stopCameraStream() {
        let stream = video.srcObject;
        if (stream) {
          let tracks = stream.getTracks();
          tracks.forEach((track) => track.stop());
        }
        video.srcObject = null;
      }

      // Función para obtener el CSRF token de Django
      function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== "") {
          const cookies = document.cookie.split(";");
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === name + "=") {
              cookieValue = decodeURIComponent(
                cookie.substring(name.length + 1)
              );
              break;
            }
          }
        }
        return cookieValue;
      }
    </script>
  </body>
</html>
